
leds.elf:     file format elf32-msp430

SYMBOL TABLE:
0000f000 l    d  .text	00000000 .text
00000200 l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
0000f1cc l    d  .rodata	00000000 .rodata
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000204 l    d  .noinit.crt0	00000000 .noinit.crt0
00000000 l    df *ABS*	00000000 main.c
0000f0c6 l       .text	00000000 __br_unexpected_
00000000 l    df *ABS*	00000000 7seg.c
00000000 g       *ABS*	00000000 __data_size
0000f0c6  w      .text	00000000 __isr_14
0000f168 g       .text	00000000 __ext_divmod16
0000f0c6  w      .text	00000000 __isr_4
0000f242 g     O .rodata	00000008 DispSegTbl
0000f1a2 g     F .text	00000000 __udivhi3
0000f1cc g       .text	00000000 _etext
00000004 g       *ABS*	00000000 __bss_size
0000f000  w      .text	00000000 __watchdog_support
0000f1c6  w      .text	00000000 __stop_progExec__
0000f0c6  w      .text	00000000 __isr_11
0000f1e6 g     O .rodata	0000005b DispASCIItoSegTbl
0000f0c6  w      .text	00000000 __isr_5
0000f1cc g       *ABS*	00000000 __data_load_start
0000f0c6 g       .text	00000000 __dtors_end
0000f0c6  w      .text	00000000 __isr_2
0000f19a g     F .text	00000000 __modhi3
0000f100 g       .text	00000000 __isr_10
00000204 g     O .noinit.crt0	00000002 __wdt_clear_value
0000f0c6  w      .text	00000000 __isr_7
0000ffe0 g     O .vectors	00000020 __ivtbl_16
0000f1bc g     F .text	00000000 __umodhi3
0000f0c6  w      .text	00000000 __isr_0
0000f028  w      .text	00000000 __do_clear_bss
0000f1c4  w      .text	00000000 _unexpected_
0000f0c6  w      .text	00000000 __isr_8
0000f0c6  w      .text	00000000 __isr_3
0000f168 g     F .text	00000000 __divhi3
0000f1a2 g       .text	00000000 __ext_udivmod16
0000f000  w      .text	00000000 _reset_vector__
0000f0c6 g       .text	00000000 __ctors_start
0000f0c6  w      .text	00000000 __isr_12
0000f010  w      .text	00000000 __do_copy_data
00000200 g       .bss	00000000 __bss_start
0000f03e g     F .text	00000088 main
0000f0c6  w      .text	00000000 __isr_13
00010000 g       .vectors	00000000 _vectors_end
0000f0ca g     F .text	00000036 delay
0000f0c6  w      .text	00000000 __isr_9
0000f00c  w      .text	00000000 __init_stack
00000200 g     O .bss	00000002 offset
0000f0c6 g       .text	00000000 __dtors_start
0000f0c6  w      .text	00000000 __isr_6
0000f0c6 g       .text	00000000 __ctors_end
00000600 g       *ABS*	00000000 __stack
0000f0c6  w      .text	00000000 __isr_1
00000200 g       .text	00000000 _edata
00000204 g       .bss	00000000 _end
0000f1c6  w      .text	00000000 _endless_loop__
0000f14a g     F .text	0000001e DispStr
0000f010  w      .text	00000000 __low_level_init
00000200 g       .text	00000000 __data_start
00000120 g       *ABS*	00000000 __WDTCTL
0000f100 g     F .text	0000004a INT_Watchdog
00000202 g     O .bss	00000002 irq_counter



Disassembly of section .text:

0000f000 <__watchdog_support>:

__watchdog_support:
#if WITH_DISABLE_WDT
	mov     #0x5a80, &__WDTCTL
#else /* WITH_DISABLE_WDT */
	mov.b	&__WDTCTL, r5
    f000:	55 42 20 01 	mov.b	&0x0120,r5	
	bis	#0x5a08, r5
    f004:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08
	mov	r5, &__wdt_clear_value
    f008:	82 45 04 02 	mov	r5,	&0x0204	

0000f00c <__init_stack>:
	.weak   __init_stack

	.func   __init_stack

__init_stack:
	mov     #__stack, r1
    f00c:	31 40 00 06 	mov	#1536,	r1	;#0x0600

0000f010 <__do_copy_data>:
	.weak   __do_copy_data

	.func   __do_copy_data

__do_copy_data:
	mov     #__data_size, r15
    f010:	3f 40 00 00 	mov	#0,	r15	;#0x0000
	tst     r15
    f014:	0f 93       	tst	r15		
	jz      .L__copy_data_end
    f016:	08 24       	jz	$+18     	;abs 0xf028
.L__copy_data_loop:
	WDTIMER_KICK
    f018:	92 42 04 02 	mov	&0x0204,&0x0120	
    f01c:	20 01 
	decd    r15
    f01e:	2f 83       	decd	r15		
	mov.w   __data_load_start(r15), __data_start(r15)    ; data section is word-aligned, so word transfer is acceptable
    f020:	9f 4f cc f1 	mov	-3636(r15),512(r15);0xf1cc(r15), 0x0200(r15)
    f024:	00 02 
	jne     .L__copy_data_loop
    f026:	f8 23       	jnz	$-14     	;abs 0xf018

0000f028 <__do_clear_bss>:
	.weak   __do_clear_bss

	.func   __do_clear_bss

__do_clear_bss:
	mov     #__bss_size, r15
    f028:	3f 40 04 00 	mov	#4,	r15	;#0x0004
	tst     r15
    f02c:	0f 93       	tst	r15		
	jz      .L__clear_bss_end
    f02e:	07 24       	jz	$+16     	;abs 0xf03e
.L__clear_bss_loop:
	WDTIMER_KICK
    f030:	92 42 04 02 	mov	&0x0204,&0x0120	
    f034:	20 01 
	dec     r15
    f036:	1f 83       	dec	r15		
	clr.b   __bss_start(r15)
    f038:	cf 43 00 02 	mov.b	#0,	512(r15);r3 As==00, 0x0200(r15)
	jne     .L__clear_bss_loop
    f03c:	f9 23       	jnz	$-12     	;abs 0xf030

0000f03e <main>:
Main function with some blinking leds
*/
int main(void) {

    int o = 0;
    irq_counter = 0;
    f03e:	82 43 02 02 	mov	#0,	&0x0202	;r3 As==00
    offset      = 0;
    f042:	82 43 00 02 	mov	#0,	&0x0200	;r3 As==00

    WDTCTL = WDTPW | WDTHOLD;          // Disable watchdog timer
    f046:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    f04a:	20 01 

    P1OUT  = 0x00;                     // Port data output
    f04c:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00
    P2OUT  = 0x00;
    f050:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00

    P1DIR  = 0x00;                     // Port direction register
    f054:	c2 43 22 00 	mov.b	#0,	&0x0022	;r3 As==00
    P2DIR  = 0xff;
    f058:	f2 43 2a 00 	mov.b	#-1,	&0x002a	;r3 As==11

    P1IES  = 0x00;                     // Port interrupt enable (0=dis 1=enabled)
    f05c:	c2 43 24 00 	mov.b	#0,	&0x0024	;r3 As==00
    P2IES  = 0x00;
    f060:	c2 43 2c 00 	mov.b	#0,	&0x002c	;r3 As==00
    P1IE   = 0x00;                     // Port interrupt Edge Select (0=pos 1=neg)
    f064:	c2 43 25 00 	mov.b	#0,	&0x0025	;r3 As==00
    P2IE   = 0x00;
    f068:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00
    //eint();                            //enable interrupts


    while (1) {                         // Main loop, never ends...

      P2OUT = 0x01;
    f06c:	d2 43 29 00 	mov.b	#1,	&0x0029	;r3 As==01
      delay(0x0007, 0xffff);
    f070:	3e 43       	mov	#-1,	r14	;r3 As==11
    f072:	3f 40 07 00 	mov	#7,	r15	;#0x0007
    f076:	b0 12 ca f0 	call	#0xf0ca	

      P2OUT = 0x02;
    f07a:	e2 43 29 00 	mov.b	#2,	&0x0029	;r3 As==10
      delay(0x0007, 0xffff);
    f07e:	3e 43       	mov	#-1,	r14	;r3 As==11
    f080:	3f 40 07 00 	mov	#7,	r15	;#0x0007
    f084:	b0 12 ca f0 	call	#0xf0ca	

      P2OUT = 0x06;
    f088:	f2 40 06 00 	mov.b	#6,	&0x0029	;#0x0006
    f08c:	29 00 
      delay(0x0007, 0xffff);
    f08e:	3e 43       	mov	#-1,	r14	;r3 As==11
    f090:	3f 40 07 00 	mov	#7,	r15	;#0x0007
    f094:	b0 12 ca f0 	call	#0xf0ca	

      P2OUT = 0x04;
    f098:	e2 42 29 00 	mov.b	#4,	&0x0029	;r2 As==10
      delay(0x0007, 0xffff);
    f09c:	3e 43       	mov	#-1,	r14	;r3 As==11
    f09e:	3f 40 07 00 	mov	#7,	r15	;#0x0007
    f0a2:	b0 12 ca f0 	call	#0xf0ca	

      P2OUT = 0x08;
    f0a6:	f2 42 29 00 	mov.b	#8,	&0x0029	;r2 As==11
      delay(0x0007, 0xffff);
    f0aa:	3e 43       	mov	#-1,	r14	;r3 As==11
    f0ac:	3f 40 07 00 	mov	#7,	r15	;#0x0007
    f0b0:	b0 12 ca f0 	call	#0xf0ca	

      P2OUT = 0x09;
    f0b4:	f2 40 09 00 	mov.b	#9,	&0x0029	;#0x0009
    f0b8:	29 00 
      delay(0x0007, 0xffff);
    f0ba:	3e 43       	mov	#-1,	r14	;r3 As==11
    f0bc:	3f 40 07 00 	mov	#7,	r15	;#0x0007
    f0c0:	b0 12 ca f0 	call	#0xf0ca	
    f0c4:	d3 3f       	jmp	$-88     	;abs 0xf06c

0000f0c6 <__ctors_end>:
    f0c6:	30 40 c4 f1 	br	#0xf1c4	

0000f0ca <delay>:
#include "7seg.h"

/**
Delay function.
*/
void delay(unsigned int c, unsigned int d) {
    f0ca:	21 82       	sub	#4,	r1	;r2 As==10
  volatile int i, j;
  for (i = 0; i<c; i++) {
    f0cc:	81 43 02 00 	mov	#0,	2(r1)	;r3 As==00, 0x0002(r1)
    f0d0:	1d 41 02 00 	mov	2(r1),	r13	;0x0002(r1)
    f0d4:	0d 9f       	cmp	r15,	r13	
    f0d6:	12 2c       	jc	$+38     	;abs 0xf0fc
    for (j = 0; j<d; j++) {
    f0d8:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00, 0x0000(r1)
    f0dc:	2d 41       	mov	@r1,	r13	
    f0de:	0d 9e       	cmp	r14,	r13	
    f0e0:	07 2c       	jc	$+16     	;abs 0xf0f0
      nop();
    f0e2:	03 43       	nop			
      nop();
    f0e4:	03 43       	nop			
Delay function.
*/
void delay(unsigned int c, unsigned int d) {
  volatile int i, j;
  for (i = 0; i<c; i++) {
    for (j = 0; j<d; j++) {
    f0e6:	91 53 00 00 	inc	0(r1)		;0x0000(r1)
    f0ea:	2d 41       	mov	@r1,	r13	
    f0ec:	0d 9e       	cmp	r14,	r13	
    f0ee:	f9 2b       	jnc	$-12     	;abs 0xf0e2
/**
Delay function.
*/
void delay(unsigned int c, unsigned int d) {
  volatile int i, j;
  for (i = 0; i<c; i++) {
    f0f0:	91 53 02 00 	inc	2(r1)		;0x0002(r1)
    f0f4:	1d 41 02 00 	mov	2(r1),	r13	;0x0002(r1)
    f0f8:	0d 9f       	cmp	r15,	r13	
    f0fa:	ee 2b       	jnc	$-34     	;abs 0xf0d8
    for (j = 0; j<d; j++) {
      nop();
      nop();
    }
  }
}
    f0fc:	21 52       	add	#4,	r1	;r2 As==10
    f0fe:	30 41       	ret			

0000f100 <INT_Watchdog>:
it shoule be a clock ;-)
it does not count days, but i think you'll get the idea.
*/
volatile int irq_counter, offset;

wakeup interrupt (WDT_VECTOR) INT_Watchdog(void) {
    f100:	0f 12       	push	r15		
    f102:	0e 12       	push	r14		
    f104:	0d 12       	push	r13		
    f106:	0c 12       	push	r12		

  irq_counter++;
    f108:	92 53 02 02 	inc	&0x0202	
  if (irq_counter == 300) {
    f10c:	1f 42 02 02 	mov	&0x0202,r15	
    f110:	3f 90 2c 01 	cmp	#300,	r15	;#0x012c
    f114:	0b 20       	jnz	$+24     	;abs 0xf12c
    irq_counter = 0;
    f116:	82 43 02 02 	mov	#0,	&0x0202	;r3 As==00
    offset = (offset+1) % 20;
    f11a:	1f 42 00 02 	mov	&0x0200,r15	
    f11e:	3e 40 14 00 	mov	#20,	r14	;#0x0014
    f122:	1f 53       	inc	r15		
    f124:	b0 12 9a f1 	call	#0xf19a	
    f128:	82 4f 00 02 	mov	r15,	&0x0200	
  }
  DispStr  (offset, "OPENMSP430 IN ACTION    ");
    f12c:	1f 42 00 02 	mov	&0x0200,r15	
    f130:	3e 40 cc f1 	mov	#-3636,	r14	;#0xf1cc
    f134:	4f 4f       	mov.b	r15,	r15	
    f136:	b0 12 4a f1 	call	#0xf14a	
}
    f13a:	3c 41       	pop	r12		
    f13c:	3d 41       	pop	r13		
    f13e:	3e 41       	pop	r14		
    f140:	3f 41       	pop	r15		
    f142:	b1 c0 f0 00 	bic	#240,	0(r1)	;#0x00f0, 0x0000(r1)
    f146:	00 00 
    f148:	00 13       	reti			

0000f14a <DispStr>:
* ASCII to seven-segment conversion table DispASCIItoSegTbl[].
*********************************************************************************************************
*/

void DispStr (INT8U offset, INT8U *s)
{
    f14a:	3c 40 42 f2 	mov	#-3518,	r12	;#0xf242
* Notes : - Not all ASCII characters can be displayed on a seven-segment display. Consult the
* ASCII to seven-segment conversion table DispASCIItoSegTbl[].
*********************************************************************************************************
*/

void DispStr (INT8U offset, INT8U *s)
    f14e:	4f 4f       	mov.b	r15,	r15	
    f150:	0f 5e       	add	r14,	r15	
{
  int dig        = 0;
  register INT8U* p;
  register INT8U c;
  while (dig < DIGIT_NR) {
    p = DispSegTbl[dig];
    f152:	3e 4c       	mov	@r12+,	r14	
    c = *(offset+s);
    *p = DispASCIItoSegTbl[c - 0x20];
    f154:	7d 4f       	mov.b	@r15+,	r13	
    f156:	3d 50 e6 f1 	add	#-3610,	r13	;#0xf1e6
    f15a:	de 4d e0 ff 	mov.b	-32(r13),0(r14)	;0xffe0(r13), 0x0000(r14)
    f15e:	00 00 
void DispStr (INT8U offset, INT8U *s)
{
  int dig        = 0;
  register INT8U* p;
  register INT8U c;
  while (dig < DIGIT_NR) {
    f160:	3c 90 4a f2 	cmp	#-3510,	r12	;#0xf24a
    f164:	f6 23       	jnz	$-18     	;abs 0xf152
    c = *(offset+s);
    *p = DispASCIItoSegTbl[c - 0x20];
    dig++;
    s++;
  }
}
    f166:	30 41       	ret			

0000f168 <__divhi3>:
__ext_divmod16:
__divhi3:
	;; r15 = N in ; Q out
	;; r14 = D in ; R out
	;; r13 = work, bit 0x02 to invert R, bit 0x01 to invert Q
	clr	r13
    f168:	0d 43       	clr	r13		
	tst	r15		; invert N?
    f16a:	0f 93       	tst	r15		
	jge	1f
    f16c:	04 34       	jge	$+10     	;abs 0xf176
	mov	#3, r13
    f16e:	3d 40 03 00 	mov	#3,	r13	;#0x0003
	inv	r15
    f172:	3f e3       	inv	r15		
	inc	r15
    f174:	1f 53       	inc	r15		
1:	tst	r14		; invert D?
    f176:	0e 93       	tst	r14		
	jge	2f
    f178:	03 34       	jge	$+8      	;abs 0xf180
	xor.b	#1, r13
    f17a:	5d e3       	xor.b	#1,	r13	;r3 As==01
	inv	r14
    f17c:	3e e3       	inv	r14		
	inc	r14
    f17e:	1e 53       	inc	r14		
2:	push	r13		; save flags
    f180:	0d 12       	push	r13		
	call	#__ext_udivmod16 ; unsigned divmod
    f182:	b0 12 a2 f1 	call	#0xf1a2	
	pop	r13		; restore flags
    f186:	3d 41       	pop	r13		
	bit.b	#2, r13		; neg rem?
    f188:	6d b3       	bit.b	#2,	r13	;r3 As==10
	jz	3f
    f18a:	02 24       	jz	$+6      	;abs 0xf190
	inv	r14
    f18c:	3e e3       	inv	r14		
	inc	r14
    f18e:	1e 53       	inc	r14		
3:	bit.b	#1, r13		; neg quot?
    f190:	5d b3       	bit.b	#1,	r13	;r3 As==01
	jz	4f
    f192:	02 24       	jz	$+6      	;abs 0xf198
	inv	r15
    f194:	3f e3       	inv	r15		
	inc	r15
    f196:	1f 53       	inc	r15		
4:	ret
    f198:	30 41       	ret			

0000f19a <__modhi3>:
	.endfunc

	.global	__modhi3
	.type	__modhi3, @function
__modhi3:
	call	#__ext_divmod16
    f19a:	b0 12 68 f1 	call	#0xf168	
	mov	r14, r15
    f19e:	0f 4e       	mov	r14,	r15	
	ret
    f1a0:	30 41       	ret			

0000f1a2 <__udivhi3>:
__udivhi3:
	;; r15 = N in ; Q out
	;; r14 = D in ; A = R out
	;; r13 = M
	;; r12 = count
	mov.b	#16, r12	; set count
    f1a2:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
	mov	r14, r13	; M := D
    f1a6:	0d 4e       	mov	r14,	r13	
	clr	r14		; A := 0
    f1a8:	0e 43       	clr	r14		
1:	rla	r15		; left shift Q ...
    f1aa:	0f 5f       	rla	r15		
	rlc	r14		; ... into left shift A
    f1ac:	0e 6e       	rlc	r14		
	cmp	r13, r14	; M < A?
    f1ae:	0e 9d       	cmp	r13,	r14	
	jlo	2f		; yes, skip adjustment
    f1b0:	02 28       	jnc	$+6      	;abs 0xf1b6
	sub	r13, r14	; no, A := A - M
    f1b2:	0e 8d       	sub	r13,	r14	
	bis	#1, r15		; set Qi
    f1b4:	1f d3       	bis	#1,	r15	;r3 As==01
2:	dec	r12
    f1b6:	1c 83       	dec	r12		
	jnz	1b
    f1b8:	f8 23       	jnz	$-14     	;abs 0xf1aa
	ret
    f1ba:	30 41       	ret			

0000f1bc <__umodhi3>:
	.endfunc

	.global	__umodhi3
	.type	__umodhi3, @function
__umodhi3:
	call	#__ext_udivmod16
    f1bc:	b0 12 a2 f1 	call	#0xf1a2	
	mov	r14, r15
    f1c0:	0f 4e       	mov	r14,	r15	
	ret
    f1c2:	30 41       	ret			

0000f1c4 <_unexpected_>:
	.global	_unexpected_
        .weak   _unexpected_

        .p2align 1,0
_unexpected_:
        reti
    f1c4:	00 13       	reti			

0000f1c6 <__stop_progExec__>:
	.global _endless_loop__
	.weak	_endless_loop__
	.func   _endless_loop__

_endless_loop__:
	bis	#0xf0, r2
    f1c6:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
	jmp  _endless_loop__
    f1ca:	fd 3f       	jmp	$-4      	;abs 0xf1c6

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	c6 f0 c6 f0 c6 f0 c6 f0 c6 f0 c6 f0 c6 f0 c6 f0     ................
    fff0:	c6 f0 c6 f0 00 f1 c6 f0 c6 f0 c6 f0 c6 f0 00 f0     ................
